     // render a map around given (lat,lng) set as center
    // if map exists already then it will only pan to given location
    showMap = function (location) {

        var latitude = location.lat,
            longitude = location.lng;

        return new Promise(function(resolve, reject) {

            console.log('showMap');

            if (!latitude || !longitude) {
                reject(Error('showMap: no params given!'))
            }

            if (map) {

                console.log('map exists already. Panning');

                map.setZoom(map_initial_zoom);
                map.panTo(location);
                resolve();
                return;
            }

            var myStyles =[
              {
                featureType: "poi",
                elementType: "labels",
                stylers: [
                  { visibility: "off" }
                ]
              }
            ];

            var mapOptions = {
                center: new google.maps.LatLng(latitude, longitude),
                zoom: map_current_zoom,
                scaleControl: true,
                zoomControl: true,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_CENTER
                },
                streetViewControl: false,
                mapTypeControl: false,
                styles: myStyles
            };

            map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);

            google.maps.event.addListenerOnce(map, 'tilesloaded', function() {
              console.log('Map is drawn');
              locationMsg(location);
              resolve();
            });



            google.maps.event.addListener(map.data, 'addfeature', function (e) {

//              var best =        e.feature.getProperty('best_at').includes('best');

              var position    = e.feature.getGeometry().get();
              var name =        e.feature.getProperty('name');
              var exchange_id = e.feature.getProperty('id');
              var rank =        e.feature.getProperty('rank');
              var errors =      e.feature.getProperty('errors');
              var eIcon;

              if (rank) {
                switch(rank) {
                  case 1:  eIcon =  '<%= asset_path 'circle_crown.png' %>'; break;
                  case 2:  eIcon =  '<%= asset_path 'rank2.png' %>'; break;
                  case 3:  eIcon =  '<%= asset_path 'rank3.png' %>'; break;
                  case 4:  eIcon =  '<%= asset_path 'rank4.png' %>'; break;
                  case 5:  eIcon =  '<%= asset_path 'rank5.png' %>'; break;
                  default: eIcon =  '<%= asset_path 'norank.png' %>'; break;
                }
              } else {
                if (errors.length) {
                  eIcon = '<%= asset_path 'lightgrey.png' %>';
                } else {
                  eIcon = '<%= asset_path 'grey.png' %>'
                }
              }

              var marker = new google.maps.Marker({
                map:          map,
                position:     position,
                title:        name,
                exchange_id:  exchange_id,
                zIndex:       exchange_id,
                optimized:    false,
                icon:         eIcon
              });


              google.maps.event.addListener(marker, 'mouseover', function () {
                console.log('map hover over ' + this.exchange_id);
                listAddClass('hover', this.exchange_id);
              });

              google.maps.event.addListener(marker, 'mouseout', function () {
                listRemoveClass('hover', this.exchange_id);
              });

//              if (!best) markerClusterer.addMarker(marker);
              markers.push(marker);

            });



          google.maps.event.addListenerOnce(map, 'idle', function () {
                // do something only the first time the map is loaded
            });


            google.maps.event.addListener(map, 'dragstart', function () {
                hide_best();
             });

            google.maps.event.addListener(map, 'dragend', function () {

              // irritating, but inevitable since i can't stick the user's blue dot to a place on the map (it's always on the screen's center)
              // re-center map around user *cuurent* position if he drags the map around
              console.log('dragend event');

/*
              setTimeout(function () {
                      showSearchLocation(user.lat, user.lng)
              }, 1000);
*/
            });

            google.maps.event.addListenerOnce(map, 'click', function () {
                hide_best();
            });


        })
    };

    panMap = function (location) {

        var latitude = location.lat,
            longitude = location.lng;

        return new Promise(function(resolve, reject) {

            console.log('panMap');

            if (!latitude || !longitude) {
                reject(Error('panMap: no params given!'))
            }

            map.panTo(location);

            google.maps.event.addListener(map, 'bounds_changed', function () {
                console.log('map is panned');
                resolve();
            });

        })
    };

     renderMap = function(exchange) {

         // TODO: Show selected exchange on map

       google.maps.event.trigger(map, 'resize');
       locationMsg(search.location);


     };


    clearGoogleMarkers = function() {
        map.data.forEach(function(feature) {
            map.data.remove(feature);
        });
    };

    fitBounds = function(exchange) {

      bounds  = new google.maps.LatLngBounds();
      bounds.extend(new google.maps.LatLng(search.location.lat, search.location.lng));
      bounds.extend(new google.maps.LatLng(exchange.properties.latitude, exchange.properties.longitude));
      map.fitBounds(bounds);

    };


    // What really places the markers on the map is the 'addfeature' listener on the map
    // It listens to / is triggered by this call here
    // That 'addfeature' listener above creates separate markers that I can feed to the cluster
    // The markers themselves that are generated by the .addGeoJson below are redundant so they are suppressed here


    placeGoogleMarkers = function() {

/*
      markerClusterer = new MarkerClusterer(map, markers, {
        imagePath: '/m',
        maxZoom: 13,
        zoomOnClick: true
      });
      markerClusterer.clearMarkers();
 */

      markers.forEach(function (marker) {
        marker.setMap(null)
      });
      markers = [];
      map.data.setMap(null);

      exchangesLayer = map.data.addGeoJson(searchResult);

      idMarkerLayer();
    };



 /*   addGoogleMarkers = function() {

        console.log('addGoogleMarkers');

        idMarkerLayer();

        return new Promise(function(resolve, reject) {

            (function loop(i) {

                var timeout = 200;
                var exchange = exchanges[i].properties;
                setTimeout(function () {

                    var marker = new google.maps.Marker({
                        map: map,
                        animation: google.maps.Animation.DROP,
                        optimized: false,
                        icon: '/rsz_logo_no_text.png',
                        zIndex: exchange.id,
                        position: {lat: exchange.latitude, lng: exchange.longitude}
                    });

                    if (--i >= 0) {
                        loop(i)
                    } else {
                        setTimeout(resolve, timeout);
                    }

                }, timeout);

            })(exchanges.length - 1);

        })

     };
*/
 /*   placeSoftMarkers = function() {
        console.log('placeSoftMarkers');
        exchanges.forEach(placeSoftMarker);
    };

    placeSoftMarker = function(exchange) {

        var exchange = exchange.properties;
        var $marker = $('.marker.template').clone().removeClass('template').attr('data-exchange_id', exchange.id);

        var deg = Math.trunc(getBearing(numeric_value_of('location_lat'), numeric_value_of('location_lng'), exchange.latitude, exchange.longitude));

        $marker.attr({'data-lat': exchange.latitude, 'data-lng': exchange.longitude, 'data-atDeg': deg});
        $marker = positionSoftMarker(null, $marker);
        $marker.appendTo('#markers');
    };

    positionSoftMarker = function(index, $marker) {
        var data = $marker.data();
        var point = fromLatLngToPoint(data.lat, data.lng, map);
        var point_width = 32, point_height = 32;
        $marker.css({left: point.x - point_width / 2, top: point.y - point_height / 2});
        return $marker;
    };
 */

    renderDirections = function (exchange) {

//        console.log('renderDirections');

      if (directionsRenderedFor == exchange.id) return;
      directionsRenderedFor = exchange.id;

      var origin = new google.maps.LatLng(search.location.lat, search.location.lng);
      var destination = new google.maps.LatLng(exchange.latitude, exchange.longitude);

      calcRoute(origin, destination);


    };


    clearDirections = function() {
//        if (directionsRenderedFor == null) return;
        if (directionsDisplay) directionsDisplay.setMap(null);
        directionsRenderedFor = null;
      $('.nav_button').removeClass('rotate');
    };


    function calcRoute(origin, destination) {

        $('#directionsPanel').empty();

        var request = {
            origin:         origin,
            destination:    destination,
            travelMode:     google.maps.TravelMode.WALKING,
            unitSystem:     google.maps.UnitSystem.METRIC
        };

        directionsService = new google.maps.DirectionsService();
        directionsDisplay = new google.maps.DirectionsRenderer({preserveViewport: true});

        directionsDisplay.setMap(map);
        directionsDisplay.setPanel(document.getElementById("directionsPanel"));

        directionsService.route(request, function (response, status) {
            console.log('directionsService.route returned with status: ' + status);
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setDirections(response);
//                setTimeout(function() {showSearchLocation(user.lat, user.lng)}, 1000);
            }
        });

    }

    findDuration = function(exchange) {

        return new Promise(function(resolve, reject) {

            if (exchange.matrix && exchange.matrix.duration && exchange.matrix.distance) { // In short, if the api had been invoked already and returned the data
              resolve(exchange.matrix);
              return;
            }

            var origin =            new google.maps.LatLng(search.location.lat, search.location.lng);
            var destination =       new google.maps.LatLng(exchange.latitude, exchange.longitude);
            var request = {
                origins: [origin],
                destinations: [destination],
                travelMode: google.maps.TravelMode.WALKING,
                unitSystem: google.maps.UnitSystem.METRIC
            };

            var service = new google.maps.DistanceMatrixService;
            service.getDistanceMatrix(request, function (response, status) {
                if (status !== 'OK') {
                    reject('google.maps.DistanceMatrixService error: ' + status);
                } else {
                    if (response && response.rows[0] && response.rows[0].elements[0] && response.rows[0].elements[0].duration) {
                        exchange.matrix.duration = response.rows[0].elements[0].duration.text;
                        exchange.matrix.distance = response.rows[0].elements[0].distance.text;
                        resolve(exchange.matrix);
                    } else {
                        console.log(response);
                        reject(new Error('google.maps.DistanceMatrixService response includes no duration/distance'))
                    }
                }
            })

        })
    };



     $('body').on('click tap', '[data-action=directions]', function(e) {
       console.log('[data-action=directions] clicked');
       renderDirections(currentExchange());
       if (mobile) unselect($(this));
       $(this).addClass('rotate');
       report('Tap', 'Directions');
     });





     fromLatLngToPoint = function(lat, lng, map) {

        var latLng = new google.maps.LatLng(lat, lng);
        var topRight = map.getProjection().fromLatLngToPoint(map.getBounds().getNorthEast());
        var bottomLeft = map.getProjection().fromLatLngToPoint(map.getBounds().getSouthWest());
        var scale = Math.pow(2, map.getZoom());
        var worldPoint = map.getProjection().fromLatLngToPoint(latLng);
        return new google.maps.Point((worldPoint.x - bottomLeft.x) * scale, (worldPoint.y - topRight.y) * scale);
    };

    // the smooth zoom function
    function smoothZoom (map, max, cnt) {

        console.log('smoothZoom', max, cnt);
        return new Promise(function(resolve, reject) {

          increaseZoom(cnt);

          function increaseZoom(cnt) {

              var zoom = map.getZoom();
              if (!map.getBounds().contains(new google.maps.LatLng(offers[0].properties.latitude, offers[0].properties.longitude))) {

                console.log('cnt is: ' + cnt + ', map zoom is: ' + zoom + ' and map no longer includes best exchange - decreasing zoom by 2');
                map_current_zoom = zoom - 2;
                map.setZoom(map_current_zoom);
                $('#map_curtain').addClass('on');
                resolve();
                return;

              } else

              if (cnt >= max) {

                console.log('cnt is: ' + cnt + ', map zoom is: ' + zoom + ' and no further zoom in required');
                map_current_zoom = zoom;
                $('#map_curtain').addClass('on');
                resolve();
                return;

              } else {

                console.log('cnt is: ' + cnt + ', map zoom is: ' + zoom + ' and further zoom is required');
                z = google.maps.event.addListenerOnce(map, 'zoom_changed', function(event){
                    google.maps.event.removeListener(z);
                    increaseZoom(cnt + 1);
                });
                setTimeout(function(){map.setZoom(cnt)}, 700);

              }

          }

        })
    }

    zoomIn = function() {
        console.log('zoomIn');
        if (offers.length == 0) {
            return;
        }
        return smoothZoom(map, map_final_zoom, map.getZoom())
    };

     focusOn = function(exchange) {

       map.panTo({lat: exchange.latitude, lng: exchange.longitude});
       map.setZoom(16);

     };

  ///
  /// markerLayer manipulation
  ///

   // define a markers layer and id it so google markers can be styled in css (as '#markerLayer img')
   // NOTE!! if not needed, then 'optimized: false' should be removed from marker creation

  idMarkerLayer = function() {
   console.log('idMarkerLayer');
   var myoverlay = new google.maps.OverlayView();
   myoverlay.draw = function () {
     this.getPanes().markerLayer.id='markerLayer';
   };
   myoverlay.setMap(map);
  };



  markerLayerAddClass = function(id, klass) {

    function markerLayerClear(klass) {
      $('#markerLayer div').removeClass(klass);
      $('#markerLayer div img').removeClass('img_' + klass);
    }

    function zIndex($e) {
      var style = $e.attr('style');
      if (!style) return;
      return style.slice(style.indexOf('z-index') + 9, style.lastIndexOf(';'));
    }

    markerLayerClear(klass);

    $('#markerLayer > div').each(function() {

       var $this = $(this);

       if (zIndex($this) == id) {
         $this.addClass(klass);
         $this.find('img').addClass('img' + '_' + klass);
         return false
       }
   })
  };


  highlightCurrentMarker = function() {

    var currExchange = currentExchange();
    if (!currExchange) return;
    var currId = currExchange.id;

//    renderDirections(currExchange);

    markerLayerAddClass(currId, 'current');

  };


