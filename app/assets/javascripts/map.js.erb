     // render a map around given (lat,lng) set as center
    // if map exists already then it will only pan to given location
    showMap = function (location) {

        var latitude = location.lat,
            longitude = location.lng;

        return new Promise(function(resolve, reject) {

            console.log('showMap');

            if (!latitude || !longitude) {
                reject(Error('showMap: no params given!'))
            }

            if (map) {

                console.log('map exists already. Panning');

                map.setZoom(map_initial_zoom);
                map.panTo(location);
                resolve();
                return;
            }

            var myStyles =[
              {
                featureType: "poi",
                elementType: "labels",
                stylers: [
                  { visibility: "off" }
                ]
              }
            ];

            var mapOptions = {
                center: new google.maps.LatLng(latitude, longitude),
                zoom: map_current_zoom,
                scaleControl: true,
                zoomControl: true,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_CENTER
                },
                streetViewControl: false,
                mapTypeControl: false,
                styles: myStyles
            };

            map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);

            google.maps.event.addListenerOnce(map, 'tilesloaded', function() {
              console.log('Map is drawn');
              resolve();
            });



            google.maps.event.addListener(map.data, 'addfeature', function (e) {

              var exchange_id = e.feature.getProperty('id');
              var best = e.feature.getProperty('best_at').includes('best');

              var marker = new google.maps.Marker({
                map: map,
                position: e.feature.getGeometry().get(),
                title: e.feature.getProperty('name'),
                exchange_id: exchange_id,
                zIndex: exchange_id,
                  optimized: false,
//                icon: best ? '<%= asset_path "48px_blue_white_in_back.png" %>' : '<%= asset_path "48px_white.png" %>'
                icon: best ? '<%= asset_path "4.png" %>' : '<%= asset_path "96_96.png" %>'
              });

//              if (!best) markerClusterer.addMarker(marker);
              markers.push(marker);

            });




            google.maps.event.addListenerOnce(map, 'idle', function () {
                // do something only the first time the map is loaded
            });


            google.maps.event.addListener(map, 'dragstart', function () {
                hide_best();
             });

            google.maps.event.addListener(map, 'dragend', function () {

              // irritating, but inevitable since i can't stick the user's blue dot to a place on the map (it's always on the screen's center)
              // re-center map around user *cuurent* position if he drags the map around
              console.log('dragend event');

/*
              setTimeout(function () {
                      showUserPosition(user.lat, user.lng)
              }, 1000);
*/
            });

            google.maps.event.addListenerOnce(map, 'click', function () {
                hide_best();
            });


        })
    };

    panMap = function (location) {

        var latitude = location.lat,
            longitude = location.lng;

        return new Promise(function(resolve, reject) {

            console.log('panMap');

            if (!latitude || !longitude) {
                reject(Error('panMap: no params given!'))
            }

            map.panTo(location);

            google.maps.event.addListener(map, 'bounds_changed', function () {
                console.log('map is panned');
                resolve();
            });

        })
    };

     renderMap = function(exchange) {

         // TODO: Show selected exchange on map

         google.maps.event.trigger(map, 'resize');

         // Added to fix absurd Savyon centering issue
         if (user.lat && user.lng) {
             map.setCenter({lat: user.lat, lng: user.lng});
         }
     };


    clearGoogleMarkers = function() {
        map.data.forEach(function(feature) {
            map.data.remove(feature);
        });
    };

    fitBounds = function(exchange) {

      bounds  = new google.maps.LatLngBounds();
      bounds.extend(new google.maps.LatLng(search.location.lat, search.location.lng));
      bounds.extend(new google.maps.LatLng(exchange.latitude, exchange.longitude));
      map.fitBounds(bounds);

    };


    // What really places the markers on the map is the 'addfeature' listener on the map
    // It listens to / is triggered by this call here
    // That 'addfeature' listener above creates separate markers that I can feed to the cluster
    // The markers themselves that are generated by the .addGeoJson below are redundant so they are suppressed here


    placeGoogleMarkers = function() {

/*
      markerClusterer = new MarkerClusterer(map, markers, {
        imagePath: '/m',
        maxZoom: 13,
        zoomOnClick: true
      });
      markerClusterer.clearMarkers();
 */

      markers.forEach(function (marker) {
        marker.setMap(null)
      });
      markers = [];
      map.data.setMap(null);

      exchangesLayer = map.data.addGeoJson(searchResult);

      idMarkerLayer();
      setTimeout(markBest, 1000);
    };



/*  TODO: Remove
     placeBestMarker = function() {


       var exchange = exchanges[0].properties;

       var marker = new google.maps.Marker({
         position: {lat: exchange.latitude, lng: exchange.longitude},
         map: map,
         title: exchange.name,
         exchange_id: exchange.id,
         zIndex: exchange.id,
         optimized: false,
         icon: '<%= asset_path "32px_blue_white.png" %>'
       });

       markers.push(marker);

     };
*/

    addGoogleMarkers = function() {

        console.log('addGoogleMarkers');

        idMarkerLayer();

        return new Promise(function(resolve, reject) {

            (function loop(i) {

                var timeout = 200;
                var exchange = exchanges[i].properties;
                setTimeout(function () {

                    var marker = new google.maps.Marker({
                        map: map,
                        animation: google.maps.Animation.DROP,
                        optimized: false,
                        icon: '/rsz_logo_no_text.png',
                        zIndex: exchange.id,
                        position: {lat: exchange.latitude, lng: exchange.longitude}
                    });

                    if (--i >= 0) {
                        loop(i)
                    } else {
                        setTimeout(resolve, timeout);
                    }

                }, timeout);

            })(exchanges.length - 1);

        })

     };

    placeSoftMarkers = function() {
        console.log('placeSoftMarkers');
        exchanges.forEach(placeSoftMarker);
    };

    placeSoftMarker = function(exchange) {

        var exchange = exchange.properties;
        var $marker = $('.marker.template').clone().removeClass('template').attr('data-exchange_id', exchange.id);

        var deg = Math.trunc(getBearing(numeric_value_of('location_lat'), numeric_value_of('location_lng'), exchange.latitude, exchange.longitude));

        $marker.attr({'data-lat': exchange.latitude, 'data-lng': exchange.longitude, 'data-atDeg': deg});
        $marker = positionSoftMarker(null, $marker);
        $marker.appendTo('#markers');
    };

    positionSoftMarker = function(index, $marker) {
        var data = $marker.data();
        var point = fromLatLngToPoint(data.lat, data.lng, map);
        var point_width = 32, point_height = 32;
        $marker.css({left: point.x - point_width / 2, top: point.y - point_height / 2});
        return $marker;
    };


    renderDirections = function (exchange) {

//        console.log('renderDirections');

      if (directionsRenderedFor == exchange.id) return;
      directionsRenderedFor = exchange.id;

      var origin = new google.maps.LatLng(search.location.lat, search.location.lng);
      var destination = new google.maps.LatLng(exchange.latitude, exchange.longitude);

      calcRoute(origin, destination);

      if (!surveyRequested) {
        surveyRequested = true;
        setTimeout(function () {
          showDialog({
            title:    'Help us improve!',
            body:     'Will you fill out a short survey?',
            default:  'Maybe later',
            primary:  'Sure',
            pane:     'survey'
          });
        }, 30000)
      }

    };


    clearDirections = function() {
//        if (directionsRenderedFor == null) return;
        directionsDisplay.setMap(null);
        directionsRenderedFor = null;
    };


    function calcRoute(origin, destination) {

        $('#directionsPanel').empty();

        var request = {
            origin:         origin,
            destination:    destination,
            travelMode:     google.maps.TravelMode.WALKING,
            unitSystem:     google.maps.UnitSystem.METRIC
        };

        directionsService = new google.maps.DirectionsService();
        directionsDisplay = new google.maps.DirectionsRenderer({preserveViewport: true});

        directionsDisplay.setMap(map);
        directionsDisplay.setPanel(document.getElementById("directionsPanel"));

        directionsService.route(request, function (response, status) {
            console.log('directionsService.route returned with status: ' + status);
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setDirections(response);
//                setTimeout(function() {showUserPosition(user.lat, user.lng)}, 1000);
            }
        });

    }

    findDuration = function(exchange) {

        return new Promise(function(resolve, reject) {

            var origin =            new google.maps.LatLng(search.location.lat, search.location.lng);
            var destination =       new google.maps.LatLng(exchange.latitude, exchange.longitude);
            var request = {
                origins: [origin],
                destinations: [destination],
                travelMode: google.maps.TravelMode.WALKING,
                unitSystem: google.maps.UnitSystem.METRIC
            };

            var service = new google.maps.DistanceMatrixService;
            service.getDistanceMatrix(request, function (response, status) {
                if (status !== 'OK') {
                    reject('google.maps.DistanceMatrixService error: ' + status);
                } else {
                    if (response && response.rows[0] && response.rows[0].elements[0] && response.rows[0].elements[0].duration) {
                        exchange.matrix.duration = response.rows[0].elements[0].duration.text;
                        exchange.matrix.distance = response.rows[0].elements[0].distance.text;
                        resolve(exchange);
                    } else {
                        console.log(response);
                        reject(new Error('google.maps.DistanceMatrixService response includes no duration/distance'))
                    }
                }
            })

        })
    }
;
    fromLatLngToPoint = function(lat, lng, map) {

        var latLng = new google.maps.LatLng(lat, lng);
        var topRight = map.getProjection().fromLatLngToPoint(map.getBounds().getNorthEast());
        var bottomLeft = map.getProjection().fromLatLngToPoint(map.getBounds().getSouthWest());
        var scale = Math.pow(2, map.getZoom());
        var worldPoint = map.getProjection().fromLatLngToPoint(latLng);
        return new google.maps.Point((worldPoint.x - bottomLeft.x) * scale, (worldPoint.y - topRight.y) * scale);
    };

    // the smooth zoom function
    function smoothZoom (map, max, cnt) {

        console.log('smoothZoom', max, cnt);
        return new Promise(function(resolve, reject) {

          increaseZoom(cnt);

          function increaseZoom(cnt) {

              var zoom = map.getZoom();
              if (!map.getBounds().contains(new google.maps.LatLng(within_radius[0].properties.latitude, within_radius[0].properties.longitude))) {

                console.log('cnt is: ' + cnt + ', map zoom is: ' + zoom + ' and map no longer includes best exchange - decreasing zoom by 2');
                map_current_zoom = zoom - 2;
                map.setZoom(map_current_zoom);
                $('#map_curtain').addClass('on');
                resolve();
                return;

              } else

              if (cnt >= max) {

                console.log('cnt is: ' + cnt + ', map zoom is: ' + zoom + ' and no further zoom in required');
                map_current_zoom = zoom;
                $('#map_curtain').addClass('on');
                resolve();
                return;

              } else {

                console.log('cnt is: ' + cnt + ', map zoom is: ' + zoom + ' and further zoom is required');
                z = google.maps.event.addListenerOnce(map, 'zoom_changed', function(event){
                    google.maps.event.removeListener(z);
                    increaseZoom(cnt + 1);
                });
                setTimeout(function(){map.setZoom(cnt)}, 700);

              }

          }

        })
    }

    zoomIn = function() {
        console.log('zoomIn');
        if (within_radius.length == 0) {
            return;
        }
        return smoothZoom(map, map_final_zoom, map.getZoom())
    };

     focusOn = function(exchange) {

       map.panTo({lat: exchange.latitude, lng: exchange.longitude});
       map.setZoom(16);

     };


  ///
  /// markerLayer manipulation
  ///

   // define a markers layer and id it so google markers can be styled in css (as '#markerLayer img')
   // NOTE!! if not needed, then 'optimized: false' should be removed from marker creation

  idMarkerLayer = function() {
   console.log('idMarkerLayer');
   var myoverlay = new google.maps.OverlayView();
   myoverlay.draw = function () {
     this.getPanes().markerLayer.id='markerLayer';
   };
   myoverlay.setMap(map);
  };


  function titleCase(string) { return string.charAt(0).toUpperCase() + string.slice(1); }

  zIndex = function($e) {
   var style = $e.attr('style');
   if (!style) return;
   return style.slice(style.indexOf('z-index') + 9, style.lastIndexOf(';'));
  };


  markerLayerAddClass = function(id, klass) {

   $('#markerLayer > div').each(function() {

       var $this = $(this);

       if (zIndex($this) == id) {
         $this.addClass(klass);
         $this.find('img').addClass('img' + titleCase(klass));
         return false
       }
   })
  };

  markBest = function() {

    if (within_radius.length == 0) return;

    var bestId = within_radius[0].properties.id;
    markerLayerAddClass(bestId, 'best');

  };

  highlightCurrentMarker = function() {

    var currExchange = currentExchange();
    if (!currExchange) return;
    var currId = currExchange.id;

//    renderDirections(currExchange);

    $('#markerLayer div').removeClass('current');
    $('#markerLayer div img').removeClass('imgCurrent');

    markerLayerAddClass(currId, 'current');

  };

